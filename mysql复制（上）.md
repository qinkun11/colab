###复制解决了什么基本问题？

 使数据保持同步

###复制会不会带来额外的开销？

  复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。除此之外，每个备库也会对主库增加一些负载（例如网络I/O开销），尤其是当备库请求从主库读取旧的二进制文件时，可能会造成更高的I/O开销。通过复制可以获得更好的读扩展，但是对于写操作要慎重，在一主多备的架构中，写操作会被执行很多次，这时候整个系统的性能取决于写入最慢的部分。

###复制解决的问题：

1. 数据分布  MySQL复制通常不会对带宽造成很大的压力

2. 负载均衡 通过MySQL复制可以将读操作分布到多个服务器上,实现对读密集型应用的优化。

3. 备份 对于备份来说,复制是一项很有意义的技术补充,但复制既不是备份也不能够取代备份。

4. 高可用性和故障切换 复制能够帮助应用程序避免MySQL单点失败,一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间。



![img](https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQEfcffueY0reDaT8agHibMbk6Pqc4ibhiccO8Pz07m9jJ4eyuPZVomxWiac5FdicwB3aOub11CqBzXQrjw/640)

###复制如何工作？

![img](https://mmbiz.qpic.cn/mmbiz_jpg/n15FO1euP4UIbQcsTbYKh5Pl9nKfL5Vr7tLMEk9BMMCicQE9j3XKYhsQ8PugtbZ9WaMLTWPeV6qicIsyEPwVkR2w/640?wx_fmt=jpeg)

1. 在主库把数据修改记录以二进制的形式写入bin log（在每次准备提交事务完成数据更新前主库写入bin log日志，Mysql会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录bin log后，主库会告诉存储引擎可以提交错误了）
2.  备库使用一个I/O线程将bin log日志读取到自己的中继（relay log）日志中（I/O线程跟主库建立一个普通的客户端连接。然后在主库上启动一个特殊的二进制转储（binlog dump）线程会读取主库上二进制文件中的事件，它不会对事件进行轮循。如果该线程追上主库线程的读取速度，那么它将进入休眠状态，直到主库发出信号量通知才会被唤醒）

3. 备库的SQL线程读取中继日志的时间，在本地执行提交。



###主备库同步的条件：

1.  在某个时间点的主库的数据快照
2. 主库当前的二进制文件，和获得数据快照时在该二进制日志文件中的偏移量，这两个值可以确认一个唯一的日志文件坐标。
3. 从快照到现在的二进制文件

###**复制的原理**

1. 基于语句的复制

   在MySQL 5.0 及之前的版本中只支持基于语句的复制( 也称为逻辑复制)，基于语句的复制模式下，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行遍。这种方式既有好处，也有缺点。最明显的好处是实现相当简单。理论上讲，简单地记录和执行这些语句，能够让主备保持同步。另一个好处是二进制日志里的事件更加紧凑，所以相对而言，基于语句的模式不会使用太多带宽。一条更新好几兆数据的语句在二进制日志里可能只占几十个字节。另外mysqlbinlog工具(本章多处会提到)是使用基于语句的日志的最佳工具。但事实上基于语句的方式可能并不如其看起来那么便利。因为主库上的数据更新除了执行的语句外，可能还依赖于其他因素。例如，同一条SQL在主库和备库上执行的时间可能稍微或很不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的SQL.例如，使用CURRENT USER() 函数的语句。存储过程和触发器在使用基于语句的复制模式时也可能存在问题。 另外一个问题是更新必须是串行的。这需要更多的锁有时候要特别关注这一点。另外不是所有的存储引擎都支持这种复制模式。尽管这些存储引擎是包括在MySQL 5.5及之前版本中发行的。

2. 基于行的复制

   MySQL 5.1开始支持基于行的复制，这种方式会将实际数据记录在二进制日志中，跟其他数据库的实现比较相像。它有其自身的一些优点和缺点。最大的好处是可以正确的复制每一行。一些语句可以被更加有效地复制。

   由于无须重放更新主库数据的查询，使用基于行的复制模式能够更高地复制数据。重放一些查询的代价可能会很高。例如，下面有一个查将数据从一个大表中汇总到小表：

   mysql> INSERT INTO summary_table(col1, col2, sum_col3)

   SELECT col1, col2, sum(col3)

   FROM enormous_table

   GROUP BY col1, col2;

   想象一下，如果表enormous_tabled 列col1和col2有三种组合，这个查询可能在源表上扫描多次，但最终只在目标表上产生三行数据。但使用基于行的复制方式，在备库上开销会小很多。这种情况下，基于行的复制模式更加高效。

   但在另一方面，下面这条语句使用基于语句的复制方式代价会小很多：

   mysql> UPDATE enormous_table SET col1=0;

   由于这条语句做了全表更新，使用基于行的复制开销会很大，因为每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大。并且会给主库上记录日志和复制增加额外的负载，更慢的日志记录则会降低并发度。

   由于没有那种模式对所有情况都是完美的，MySQL能够在这两种复制模式间动态切换，默认情况下使用的是基于语句的复制方式，但如果发现语句无法正确地复制，就切换到基于行的复制模式。还可以根据需要来设置会话级别的变量binlog_format，控制二进制日志格式。

   对于基于行的复制模式，很难进行时间点恢复，但这并非不可能。